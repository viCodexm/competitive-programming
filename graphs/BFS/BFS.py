#Поиск в ширину (используем очередь)

from queue import Queue #Импорт очереди
def BFS(G, N): #G - граф в виде списка смежности, N - начальная вершина
    q = Queue() #Создаем очередь
    distances = [float('inf')] * len(G) #Список расстояний в ребрах от заданной вершины N
    parents = [float('inf')] * len(G) #Список родителей вершин ,где вершина i была достигнута через вершину parent[i]
    distances[N-1] = 0 #Устанавливаем расстояние до начальной вершины 0
    parents[N-1] = N #Родитель начальной вершины он сам
    q.put(N) #Кладем в очередь начальную вершину
    while not q.empty(): #Пока очередь не пуста
        item = q.get() #Снимаем с очереди первую вершину
        for i in G[item]: #Обходим смежные вершины с вершиной из очереди
            if distances[i-1] == float('inf'): #Если еще не учитывали смежную вершину
                distances[i-1] = distances[item-1] + 1 #Расстояние до смежной вершины
                parents[i-1] = item #Записываем родителя смежной вершины
                q.put(i) #Кладем в очередь смежную вершину
    return distances, parents #Возвращаем расстояние и родителей

#Вычисление пути от начальной вершины до конечной через список родителей (Вывод маршрута задом наперед)
def Road(par, first, last): #par - граф, first - начальная вершина, last - конечная вершина
    if par[last-1] == float('inf'):
        print('inf')
    else:
        while first != last:
            print(last, end=' -> ')
            last = par[last-1]
        print(last)


graph = {1: {2, 4},
         2: {1, 3},
         3: {2, 5, 6},
         4: {1, 5, 7},
         5: {3, 4, 8},
         6: {3, 8},
         7: {4, 8},
         8: {5, 6, 7, 9},
         9: {8}}

N = 4 #Начальная вершина
D, P = BFS(graph, N) #D - список расстояний, P - список родителей

print(D, P)

for i in graph:
    print(f'{i}: ', end='')
    Road(P, N, i)
