#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <functional> // std::less

using namespace std;

int main() {

	int n; cin >> n; //Вводим кол-во элементов во входном массиве
	vector<int> input(n); //Входной массив
	priority_queue<int, vector<int>, std::less<int>> ones; //Позиции единиц в массиве n (через очередь от самой правой позиции к самой левой)
	vector<int> twos; //Позиции двоек в массиве n

	for (int i = 0; i < n; ++i) { //Перебираем входной массив поэлементно
		cout << "get " << i + 1 << endl; //Получаем номера каждого элемента в массиве (истратили половину запросов, т.е N)
		cin >> input[i]; //Вводим элемент в массив
		switch (input[i]) { //В зависимости от значения элем-та добваляем его позицию в нужную структуру
		case 1:
			ones.push(i);
			break;
		case 2:
			twos.push_back(i);
			break;
		}

//		fflush(stdout); //Очищаем stdout от мусора (А может не надо?)
	}

	//twos упорядочен по возрастанию позиций

	int ptr = input.size()-1; // указатель на последний элемент во входном массиве
	int tw = 0; // указатель на первый элемент в векторе позиций двоек

	//Сначало передвигаем все двойки в правую сторону
	if (! twos.empty()) //Если есть двойки
        while (tw < twos.size() && ptr > twos[tw]) { //пока не перебрали все двойки (не трогаем двойки справа от указателя, т.к они уже в нужном порядке)

            // если нашли импостера(не двойку) - меняем местами двойку и импостера
            if (input[ptr] != 2) {
                if (input[ptr] == 1) {
                    ones.pop(); // т.к. шли с конца, то встретили последнюю единицу в массиве
                    ones.push(twos[tw]); // добавим в очередь новой адрес единицы, которая поменялась с двойкой(т.е. адрес прежней двойки, с которой поменяли единицу),
                }                                                               // и вау, раз мы добавляем в очередь с приоритетом, то она встанет куда надо
                swap(input[ptr], input[twos[tw]]); //Меняем местами импостера и двойку
                cout << "swap " << ptr + 1 << " " << twos[tw] + 1 << "\n"; //Выводим, что мы поменяли местами
                // сдвигаем указатель на следующую двойку
                tw++;
            }
            // сдвигаем указатель ptr влево
            ptr--;
        }
    //После выполненной функции мы потратили максимум кол-во двоек в массиве операций. Мы можем еще потратить кол-во нолей + кол-во единиц операций

    vector<int> ones_vec;
	while (!ones.empty()) { //Перекидываем позиции единиц из очереди в массив
		ones_vec.push_back(ones.top());
		ones.pop();
	}

	reverse(ones_vec.begin(), ones_vec.end()); //Сортируем массив по возрастанию индекса единиц

	// ptr оставляем там же, так как знаем, что справа от него все двойки
	int ow = 0; // указатель на первый элемент в векторе позиций единиц
	if (!ones_vec.empty()) //Если есть единицы
        while (ow < ones_vec.size() && ptr > ones_vec[ow]) { //Перебираем единицы справа налево (не трогаем единицы справа от указателя, т.к они уже в нужном порядке)

            if (input[ptr] == 0) { // двоек быть не должно! мы их убрали направо
                swap(input[ptr], input[ones_vec[ow]]);
                cout << "swap " << ptr + 1 << " " << ones_vec[ow] + 1 << "\n";
                ow++;
            }
            ptr--;
        }
    //После выполненной функции мы потратили максимум кол-во единиц в массиве операций. В итоге всего мы можем потратить N + кол-во двоек + кол-во единиц операций,
    //что меньше 2N на кол-во нолей (в самом худшем случае нолей может не быть, тогда мы используем ровно 2N операций)

	// надеемся, что все работает!

	cout << "Sorted!";
	return 0;
}
