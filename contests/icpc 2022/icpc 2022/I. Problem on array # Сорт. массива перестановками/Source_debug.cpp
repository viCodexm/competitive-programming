#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <functional> // std::less
using namespace std;

int main() {
    setlocale(LC_ALL, "Russian");
	int n; cout << "Кол-во элементов в массиве: "; cin >> n; //Вводим кол-во элементов во входном массиве
	vector<int> input(n); cout << "Входной массив:" << endl; //Входной массив
	priority_queue<int, vector<int>, std::less<int>> ones, ones_debug; //Позиции единиц в массиве n (через очередь от самой правой к самой левой)
	vector<int> twos; //Позиции двоек в массиве n
    vector<int> poz_debug; //Номера элементов в массиве

	for (int i = 0; i < n; ++i) { //Перебираем входной массив поэлементно
	//	cout << "get " << i + 1 << endl; //Получаем номера каждого элемента в массиве (истратили половину запросов, т.е N)
        poz_debug.push_back(i + 1);
		cin >> input[i]; //Вводим элемент в массив
		switch (input[i]) { //В зависимости от значения элем-та добваляем его позицию в нужную структуру
		case 1:
			ones.push(i);
			break;
		case 2:
			twos.push_back(i);
			break;
		}

//		fflush(stdout); //Очищаем stdout от мусора (А может не надо?)
	}

	cout << endl << "====================" << endl << "Отладочная информация" << endl << "====================" << endl;
	ones_debug = ones;
    cout << "Входной массив (сверху позиция числа в массиве, снизу само число):" << endl;
    for (int i = 0; i < input.size(); i++) cout << "  "<< i; cout << endl;
    for (int i = 0; i < input.size(); i++){
        cout << "  ";
        if (i > 9) cout << " ";
        if (i > 99) cout << "  ";
        cout << input[i];

    }

	cout << endl << "Содержимое очереди с позициями единиц: " << endl;
	while (!ones_debug.empty()) {cout << ones_debug.top() << " "; ones_debug.pop();}

    cout << endl << "Содержимое массива с позициями двоек: " << endl;
	for (int i = 0; i < twos.size(); i++) cout << twos[i] << " ";



	//ones, twos упорядочены по возрастанию позиций

	int ptr = input.size()-1; // указатель на последний элемент во входном массиве
	int tw = 0; // указатель на первый элемент в векторе позиций двоек

	//Сначало передвигаем все двойки в правую сторону
	if (! twos.empty()) //Если есть двойки
        while (tw < twos.size() && ptr > twos[tw]) { //пока не перебрали все двойки (не трогаем двойки справа от указателя, т.к они уже в нужном порядке)

            // если нашли импостера(не двойку) - меняем местами двойку и импостера
            if (input[ptr] != 2) {
                if (input[ptr] == 1) {
                    ones.pop(); // т.к. шли с конца, то встретили последнюю единицу в массиве
                    ones.push(twos[tw]); // добавим в очередь новой адрес единицы, которая поменялась с двойкой(т.е. адрес прежней двойки, с которой поменяли единицу),
                }                                                               // и вау, раз мы добавляем в очередь с приоритетом, то она встанет куда надо
                swap(input[ptr], input[twos[tw]]); //Меняем местами импостера и двойку
               // cout << "swap " << ptr + 1 << " " << twos[tw] + 1 << "\n"; //Выводим, что мы поменяли местами
                // сдвигаем указатель на следующую двойку
                tw++;
            }
            // сдвигаем указатель ptr влево
            ptr--;
        }
    //После выполненной функции мы потратили максимум кол-во двоек в массиве операций. Мы можем еще потратить кол-во нолей + кол-во единиц операций


    cout << endl << "Отсортированный массив - все двойки справа (сверху позиция числа в массиве, снизу само число):" << endl;
    for (int i = 0; i < input.size(); i++) cout << "  "<< i; cout << endl;
    for (int i = 0; i < input.size(); i++){
        cout << "  ";
        if (i > 9) cout << " ";
        if (i > 99) cout << "  ";
        cout << input[i];

    }

    vector<int> ones_vec;
	while (!ones.empty()) { //Перекидываем позиции единиц из очереди в массив
		ones_vec.push_back(ones.top());
		ones.pop();
	}

	reverse(ones_vec.begin(), ones_vec.end()); //Сортируем массив по возрастанию индекса единиц

	cout << endl << "Содержимое массива с позициями единиц: " << endl;
	for (int i=0; i< ones_vec.size(); i++) cout << ones_vec[i] << " ";
	// ptr оставляем там же, так как знаем, что справа от него все двойки
	int ow = 0; // указатель на первый элемент в векторе позиций единиц
	if (!ones_vec.empty()) //Если есть единицы
        while (ow < ones_vec.size() && ptr > ones_vec[ow]) { //Перебираем единицы справа налево

            if (input[ptr] == 0) { // двоек быть не должно! мы их убрали направо
                swap(input[ptr], input[ones_vec[ow]]);
         //       cout << "swap " << ptr + 1 << " " << ones_vec[ow] + 1 << "\n";
                ow++;
            }
            ptr--;
        }

    cout << endl << "Отсортированный массив - все нули слева, все двойки справа (сверху позиция числа в массиве, снизу само число):" << endl;
    for (int i = 0; i < input.size(); i++) cout << "  "<< i; cout << endl;
    for (int i = 0; i < input.size(); i++){
        cout << "  ";
        if (i > 9) cout << " ";
        if (i > 99) cout << "  ";
        cout << input[i];

    }

    //После выполненной функции мы потратили максимум кол-во единиц в массиве операций. В итоге всего мы можем потратить N + кол-во двоек + колво единиц операций,
    //что меньше 2N на кол-во нолей (в самом худшем случае нолей может не быть, тогда мы используем ровно 2N операций)

	// надеемся, что все работает!

//	cout << "Sorted!";
	return 0;
}
