### [В Python переменных в классическом понимании НЕТ !!!](https://www.youtube.com/watch?v=8GpI0PAGniA&list=LL&index=2)

Переменные – **это этикетки**, а не ящики. Стандартная метафора «переменные – это ящики» ведет к  непониманию ссылочных переменных в  объектно-ориентированных языках. Переменные в Python похожи на ссылочные переменные в Java, поэтому лучше представлять их как этикетки, приклеенные к  объектам. 

Ниже наглядно представлено, почему метафора ящика не годится для Python, тогда как метафора
этикетки правильно описывает, как в действительности работают переменные.

```Python
1. >>> a = [1, 2, 3]
2. >>> b = a 
3. >>> a.append(4)
4. >>> b
[1, 2, 3, 4]
```

1. Создать список [1, 2, 3] и связать с ним переменную **a**
2. Связать переменную **b** с тем же значением, на которое ссылается **a**.
3. Изменить список, на который ссылается **a**, добавив в конец еще один элемент.
4. Можно наблюдать, как это отразилось на переменной **b**. Если считать
**b** ящиком, в котором хранилась копия списка [1, 2, 3] из ящика **a**, то такое
поведение бессмысленно.

<ins>Подробнее</ins>: Лусиану Рамальо. Python – к  вершинам мастерства, 2-e издание. <ins>Начиная с  главы 6, стр. 210</ins> ([Сссылка на книгу](https://vk.com/wall-203365865_965))

(Рекомендую прочитать эту главу как минимум до раздела "Относительная неизменяемость кортежей". Эта идея заложит хороший старт при изучении Python. Сама книжка тоже хорошая, но для новичков м.б. сложной )

[Почему существует так много Питонов?](https://habr.com/ru/articles/209812/) Можно почитать про CPython

[Визуализация создания объектов в памяти](https://pythontutor.com/visualize.html#mode=edit)

В Python **ВСЕ есть объект** - функции, экземпляры классов, даже сами классы являются объектами (отсюда можно сделать вывод, что типы данных тоже объекты, поскольку они реализованы как класс). Это можно увидеть во встроенном модуле **builtins** (файлы *builtins.pyi builtins.py*)

[Понимание модуля builtins](https://tushar.lol/post/builtins/)

Но раз классы являются объектами, кто же тогда создает сами классы?

[Понимание метаклассов в Python (продвинутый уровень)](https://habr.com/ru/articles/145835/)

---
## Составные операторы присваивания

A += B, использовать предпочтительнее (и другие сокращенные формы операций), чем A = A + B, поскольку не создается лишний объект (это касается только изменяемых объектов)

[Как устроен список и кортеж (сам канал тоже годный)](https://www.youtube.com/watch?v=V3qZ6gJwBzk)

Объяснение возникновения исключения на 17:40 для видео выше:

Здесь может понадобится знать, что такое магические методы (dunder methods). dunder от словосочетания double underline (двойное подчеркивание).

[Почему += неожиданно ведет себя в списках?](https://stackoverflow.com/questions/2347265/why-does-behave-unexpectedly-on-lists/2347423)

Неизменяемые объекты, такие как кортежи не переопределяют \_\_iadd__ метод, реализующий оператор +=, поэтому a_tuple[0] += ['oops'] эквивалентно a_tuple[0] = a_tuple[0] + ['oops']. (То есть сначала мы прибавили один список к другому, эта операция завершилась, а затем мы попытались присвоить результат элементу кортежа, что и вызвало исключение (т.к. кортеж неизменяем). Операция добавления списка к списку не отменилась)

[Изучаем это (очееень полезно)](https://iqbotan.blogspot.com)

[Использование join для объединения строк вместо конкатенации через "+" ](https://skillbox.ru/media/base/obedinenie-strok-v-python/)

## Ускорение ввода/вывода

Вместо использования функций **input() и print()**, которые являются оберткой, напрямую пишем в **stdin и stdout**. С ними нужно работать, как с файлами (**stdin** для чтения, **stdout** для вывода).

Их можно импортировать из встроенной библиотеки:

```python
from sys import stdin, stdout
```

Либо пользоваться ключевым словом **open** и передать туда дескриптор файла (для **stdin - 0**, для **stdout - 1**). Эта команда вернет ссылку на объект **stdin** или **stdout**.

```python
input, output = open(0), open(1, "w")
```

[Подробнее как с этим работать](https://pythononline.ru/osnovy/python-stdin-stdout-stderr)


## [Официальная документация по Python (тоже хороша)](https://docs.python.org/3/tutorial/index.html)