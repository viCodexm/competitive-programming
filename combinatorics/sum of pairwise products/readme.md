# Сумма попарных произведений массива
## Интуитивное понимание работы алгоритма

Пусть есть набор чисел:
$a_1, a_2, a_3, ...,a_{n-1},a_n$

Нужно найти такую сумму: 
$((a_1 * a_2) + (a_1 * a_3) + ... + (a_1 * a_n)) + ((a_2 * a_3) + (a_2 * a_4) + ... + (a_2 * a_n) + ... + (a_{n-1}*a_n))$

То есть мы умножаем первый элемент на все, идущие после него, затем берем второй элемент, также умножаем его на все, идущие после него и т.д., а в конце складываем полученные произведения.

Вынесем общие слагаемые за скобки:
$a_1*(a_2 + a_3 + ... + a_n) + a_2*(a_3 + a_4 + ... + a_{n-1} + a_n) + ... + a_{n-1}*(a_n)$

Заметим, что каждое слагаемое состоит из двух множителей: 1-й множитель - элемент нашего массива ($a_1, a_2, ...,a_n$), а второй множитель - сумма элементов массива, начиная от следущего элемента после первого множителя, заканчивая последним элементом массива.

Первый множитель у нас есть (это сам элемент массива), а второй мы будем накапливать по мере вычисления очередного слагаемого, идя с конца массива. Вообще, можно идти с начала массива, эффект будет тот же (так и сделаем).

<ins>**На примере:**</ins> 

Пусть даны элементы: 1, 2, 3, 4

Тогда их сумма попарных произведений будет такой (идем с конца):

(4 * 3 + 4 * 2 + 4 * 1) + (3 * 2 + 3 * 1) + (2 * 1) = 35

Или если вынести общие множители за скобки:

4 * (3 + 2 + 1) + 3 * (2 + 1) + 2 * (1)

Перегруппируем слагаемые:

2 * (1) + 3 * (1 + 2) + 4 * (1 + 2 + 3)

* 2, 3, 4 - элементы массива, расположенные друг за другом (начиная со второго элемента)
* (1), (1 + 2), (1 + 2 + 3) - накапливающаяся сумма (сначала мы взяли первый элемент массива 1, затем прибавили к нему второй, т.е. 2 (получилось 3). Далее к этой сумме прибавили 3 и получили 6)). Как видно, последний элемент не участвует в этой сумме.

Итоговая формула будет такой:

$S = a_2 * (a_1) + a_3 * (a_1 + a_2) + a_4 * (a_1 + a_2 + a_3) + ... + a_{n-1}*(a_1 + a_2 + ... + a_{n-2}) + a_{n}(a_1 + a_2 + ... + a_{n-1})$

## Асимптотика
Время: O(n)

Память: O(1)

---
<details>
<summary><ins>Код на Python</ins></summary>

На входе список или кортеж
```python
def sumProductsOfPairs(lst):
    total = acc = 0
    for x in lst:
        total += acc * x
        acc += x
        # Если нужен модуль
        # total %= module
        # acc %= module
    return total
```
</details>

---
<details>
<summary><ins>Код на C++</ins></summary>

На входе массив
```c++
long long sumProductsOfPairs(int *lst, int n){
    long long total = 0, acc = 0;
    for (int i = 0; i < n; ++i){
        total += acc * lst[i];
        acc += lst[i];
        // Если нужен модуль
        // total %= module;
        // acc %= module;
    }
    return total;
}
```
</details>

--- 
<br></br>

## Другой алгоритм для данной задачи
### (асимптотика та же, сам алгоритм попроще для запоминания, но если нужно брать модуль, то лучше использовать алгоритм выше, т.к. в этом используется деление)

Сумму попарных произведений k чисел можно найти посчитав произведение каждого на сумму ряда без него и поделить пополам.

Пусть есть набор чисел:
$a_1, a_2, a_3, ...,a_{n-1},a_n$

Выпишем такую сумму, где $a_i * a_j$ будет участвовать дважды:
$a_1 * (a_2 + a_3 + ... + a_n) + a_2 * (a_1 + a_3 + ... + a_n) + ... + a_n * (a_1 + a_2 + ... + a_{n-1})$

Мы умножили каждый элемент на все, кроме него, затем сложили эти произведения.

Поскольку в нашей сумме $a_i * a_j$ встречается дважды, то чтобы получить конечный ответ, эту сумму нужно поделить пополам.



---
<details>
<summary><ins>Код на Python</ins></summary>

```python
def sumProductsOfPairs(lst):
    s = sum(lst)
    total = 0
    for x in lst:
        total += x * (s - x)
    return total // 2
```
</details>

---
<details>
<summary><ins>Код на C++</ins></summary>

На входе массив
```c++
long long sumProductsOfPairs(int *lst, int n){
    long long s = 0, total = 0;
    for (int i = 0; i < n; ++i)
        s += lst[i];
    for (int i = 0; i < n; ++i)
        total += lst[i] * (s - lst[i]);
    return total / 2;
} 
```
</details>

---


[Задача, где это применяется](</contests/ICPC CRRC 2022/1-8 Done/L $Составление минимального отрезка>)