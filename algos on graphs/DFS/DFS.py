#Поиск в глубину (используем стек)

def DFS(G, N):
    used = {N} #Список посещенных вершин
    parents = [float('inf')] * len(G)  # Список родителей вершин ,где вершина i была достигнута через вершину parent[i]
    parents[N - 1] = N  # Родитель начальной вершины он сам
    st = []  # Создаем cтек
    st.append(N)  # Кладем в стек начальную вершину
    while st:  # Пока стек не пуст
        item = st[-1]  # Берем последнюю вершину стека
        if G[item] <= used: #Если посетили всех соседей вершины, то выкидываем эту вершину из стека
            st.pop()
        else:
            for i in (G[item] - used):  # Обходим смежные вершины с вершиной из стека
                st.append(i) #Добавляем вершину в стек
                used.add(i) #Добавляем вершину в посещенные
                parents[i - 1] = item  # Записываем родителя вершины
                break #Идем к соседу выбранной вершины
    return parents  # Возвращаем список родителей вершин


#Вычисление пути от начальной вершины до конечной через список родителей (Вывод маршрута задом наперед)
#+ вычисляет расстояния по списку родителей
def Road(par, first, last): #par - граф, first - начальная вершина, last - конечная вершина
    distance = 0 #Расстояние от начальной вершины до конечной
    if par[last-1] == float('inf'):
        print('inf')
    else:
        while first != last:
            distance += 1
            print(last, end=' -> ')
            last = par[last-1]
        print(last)
    return distance

graph = {1: {2, 4},
         2: {1, 3},
         3: {2, 5, 6},
         4: {1, 5, 7},
         5: {3, 4, 8},
         6: {3, 8},
         7: {4, 8},
         8: {5, 6, 7, 9},
         9: {8}}

#Примечание {} - пустой словарь, а не множество!
# Для создания пустого множества используйте конструкцию set()

N = 4 #Начальная вершина
P = DFS(graph, N) #Список родителей

D = [] #Список расстояний
for i in graph:
    print(f'{i}: ', end='')
    D.append(Road(P, N, i))

print(D, P)
