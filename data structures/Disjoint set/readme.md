# Для чего нам Union Find / Disjoint-set-union (DSU)?
### Если просто, то:
- Хотим узнать к какому множеству принадлежит элемент
- Хотим объединить множества
- Можно минимальный остов построить :)
- И много чего еще... (но это не точно)

#### А теперь по-умному:  
DSU (Disjoint Set Union), также известный как Union-Find, представляет собой эффективную структуру данных,
используемую для решения задач, связанных с разбиением множества элементов на группы (наборы)
и выполнением операций объединения и поиска в этих наборах.
**DSU полезен в различных алгоритмах и задачах, включая:**

- Кластеризация данных: объединение объектов в кластеры или группы на основе их сходства или отношений.
- Компоненты связности в графах: позволяет определить компоненты связности в графе, что полезно для анализа связей между вершинами.
- Кратчайшие пути в лесах и деревьях: может использоваться для нахождения кратчайших путей между вершинами в ациклических графах, таких как деревья.
- Оптимизация задач на графах: может помочь в оптимизации операций объединения и поиска в алгоритмах, таких как алгоритм Краскала для поиска минимального остовного дерева во взвешенных графах.
- Оптимизация кластеризации и объединения операций в базах данных: может использоваться для управления операциями объединения и поиска в базах данных.
- Другие алгоритмы и задачи: может применяться в различных ситуациях, когда требуется эффективная работа с наборами элементов и их группировка.

## Ладно. Как?
### Идея.
Идея проста - что бы понять в каком множестве находиться элемент достаточно назначить одного представителя для этого множества.
Возьмем массив `parent`, в котором каждый элемент будет указывать на самого себя (N множеств)  
Формат такой: внутри `parent[idx]` лежит либо тот же `idx`, тогда элемент с этим индексом - представитель множества, либо другой индекс `nIdx` - тогда этот элемент принадлежит к тому же множеству, что и другой индекс.  
На картинке два множества звездочек со своим представителем.
Как понять, что это представитель? - он указывает на самого себя,  
![image](https://github.com/viCodexm/competitive-programming/assets/116115112/667d9a07-ea6a-45e6-ac71-b04956324201)  
Что бы объединить множества достаточно для представителя подчиняемого множества поставить указатель не на себя, а на представителя доминирующего множества  
![image](https://github.com/viCodexm/competitive-programming/assets/116115112/783cafee-b342-4cd7-97f5-a12cdcca0d23)  
Что бы оптимизировать структуру можно перевешивать элементы множества напрямую к представителю при обращении, что бы уменьшить путь до представителя.


### Реализация.
Возьмем универсальное множество U - все имеющиеся у нас объекты. В общем количестве N объектов.
создадим массив `parent` размера `N`:
```
#define all(v)		v.begin(), v.end()
struct DisjointSet {
	vector<int> parent;
	DisjointSet(int size) {
		parent.resize(size);
		std::iota(all(parent), 1);
	}
};
```
Мы заполнили `parent` возрастающей последовательностью 1, 2, 3 .. N
так как изначально все элементы находяться в своем множестве

что бы получить представителя множества идем по ссылкам, пока не наткнемся на элемент, указывающий на самого себя.  
```
int getRep(int i) {
	if (parent[i] != i)
		// подвязываем напрямую к представителю, для уменьшения пройденного пути при повторном обращении
		parent[i] = getRep(parent[i]);
	return parent[i];
}
```
что бы объеденить два множества, достаточно выбрать любое из них и представителя одного подцепить к другому.  
```
bool join(int u, int v) {
	int RepU = getRep(u);
	int RepV = getRep(v);
	// если два элемента уже в одном множестве - вернем false, как индикатор этого (в некоторых задачах это используется, а в некоторых - нет)
	if (RepU == RepV)
		return false;
	// привязываем к любому если для нас это не важно
	if (rand() % 2)
		parent[RepU] = RepV;
	else parent[RepV] = RepU;
	return true;
}
```
